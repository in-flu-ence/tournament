#!/usr/bin/env python
# 
# tournament.py -- implementation of a Swiss-system tournament
#
import psycopg2


# Connecting to PSQL tournament database
def connect(database_name="tournament"):
    """Connect to the PostgreSQL database.  Returns a database connection."""
    try:
        db = psycopg2.connect("dbname={}".format(database_name))
        cursor = db.cursor()
        return db, cursor
    except:
        print("<error message>")


# Table deletion functions in PSQL
def deletePlayers():
    """
    Remove all the player records in players and scoreboard table for all
    tournament from the database and reset players id sequence to start from 1
    """
    db, cursor = connect()
    cursor.execute("DELETE FROM players;")
    cursor.execute("ALTER SEQUENCE players_pid_seq RESTART WITH 1;")
    db.commit()
    db.close()


def deleteMatches():
    """
    Remove all the match records from the database and reset match id sequence
    to start from 1
    """
    db, cursor = connect()
    cursor.execute("DELETE FROM matches;")
    cursor.execute("ALTER SEQUENCE matches_mid_seq RESTART WITH 1;")
    db.commit()
    db.close()


def deleteTournaments():
    """
    Remove all the tournament records from the database but keeping sequence
    rolling to avoid duplication
    """
    db, cursor = connect()
    cursor.execute("DELETE FROM tournaments;")
    cursor.execute("ALTER SEQUENCE tournaments_tid_seq RESTART WITH 1;")
    db.commit()
    db.close()


# Registering tournament & players
def registerTournament(name):
    """Adds a tournament to database.

    The database assigns a unique serial id number for each tournament. (This
    should be handled by your SQL database schema, not in your Python code.)

    Args:
      name: the tournament name (need not be unique).

    Returns:
      t_id: the id of tournament generated by the system.
    """
    db, cursor = connect()
    query = "INSERT INTO tournaments (tname) VALUES (%s) RETURNING tid;"
    parameter = (name,)
    cursor.execute(query, parameter)
    t_id = cursor.fetchone()[0]
    db.commit()
    db.close()
    return t_id


def registerPlayer(name, **kwargs):
    """Adds a player to the tournament database.

    The database assigns a unique serial id number for the player.  (This
    should be handled by your SQL database schema, not in your Python code.)

    Args:
      name: the player's full name (need not be unique).
    """

    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    db, cursor = connect()
    query = "INSERT INTO players (pname,ptid) VALUES (%s, %s);"
    parameter = (name, tid,)
    cursor.execute(query, parameter)
    db.commit()
    db.close()


# Counting Players for code testing
def countPlayers(**kwargs):
    """
    Returns the number of players currently registered in a specific
    tournament.

    Args:
        tid: tournament id from tournament table (Optional) (Default as 1)
    """
    db, cursor = connect()

    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    playercount = "SELECT COUNT(pid) FROM players WHERE ptid=%s;"
    parameter = (tid,)
    cursor.execute(playercount, parameter)
    p_count = cursor.fetchone()[0]
    return p_count


# Assigning player standings and pairing for scorecard
def playerStandings():
    """Returns a list of the players and their win records, sorted by wins.

    The first entry in the list should be the player in first place, or a player
    tied for first place if there is currently a tie.

    Standing is arranged in the following order:
    1) Opponent Match Win for equal score
    2) Total no. of matches played

    Returns:
      A list of tuples, each of which contains (id, name, wins, matches):
        id: the player's unique id (assigned by the database)
        name: the player's full name (as registered)
        wins: the number of matches the player has won
        matches: the number of matches the player has played
    """

    db, cursor = connect()

    # Create standing for specific tournament and fetch data

    stand_view = "CREATE VIEW standings AS Select players.pid, players.pname, (Select Count(matches.winner) From matches " \
                 "WHERE (players.pid = matches.winner) AND (tie is FALSE)) AS win_count, (SELECT COUNT(matches.mid) FROM " \
                 "matches where players.pid = matches.winner OR players.pid = matches.loser) AS match_played FROM players " \
                 "ORDER BY win_count DESC, match_played DESC;"
    cursor.execute(stand_view)

    omw_view = "CREATE VIEW omw AS SELECT pid, sum(win_count) AS total_win FROM standings WHERE pid IN (SELECT loser " \
               "FROM matches WHERE winner = pid) OR pid IN (SELECT winner FROM matches WHERE loser = pid) GROUP BY pid;"
    cursor.execute(omw_view)

    query = "SELECT standings.pid, standings.pname,standings.win_count,standings.match_played FROM standings " \
            "LEFT JOIN omw ON standings.pid = omw.pid ORDER BY standings.win_count DESC, omw.total_win DESC," \
            " standings.match_played DESC;"

    cursor.execute(query)
    standings = cursor.fetchall()
    return standings


def reportMatch(winner, loser, **kwargs):
    """Records the outcome of a single match between two players.

    Args:
      winner:  the id number of the player who won
      loser:  the id number of the player who lost
      tie: Boolean result to check if match is a draw (optional). Default as false.
      bye: Boolean result to check if match is a bye win (optional). Default as false.

    Features:
    Assign winner/loser according to the following at the winner column
    for winner, players.id will be inserted.

    """
    db, cursor = connect()

    if 'tie' in kwargs:
        tie = kwargs['tie']
    else:
        tie = False

    if 'bye' in kwargs:
        bye = kwargs['bye']
    else:
        bye = False

    cursor.execute("INSERT INTO matches(winner,loser,tie,bye) VALUES(%s,%s,%s,%s);", (winner, loser, tie, bye))

    db.commit()
    db.close()


def checkRematch(p1id, p2id):
    """Check if the 2 selected players have played in previous matches within the same tournament.

        Args:
          p1id:  the id number of the first player
          p2id:  the id number of the second player

        Return:
          True: Players have played in past match within the same tournament
          False: Players have not played in past match within the same tournament
    """

    # To prevent rematch
    db, cursor = connect()

    cursor.execute(
        "SELECT winner, loser FROM matches WHERE ((winner = %s AND loser = %s)"
        "OR (winner = %s AND loser =%s));",
        (p1id, p2id, p2id, p1id))
    pastplay = cursor.fetchone()
    if pastplay is not None:
        return True
    return False


def checkBye(pid):
    """Check if the selected player has been won with a skipped round (bye) in past matches within the tournament.

        Args:
          pid:  the id number of the player

        Return:
          True: Player has a skipped round previously in the tournament
          False: Player has no skipped round in the tournament
          Error: More than 1 skipped round win has been granted to player. (For development fault finding)
    """

   # To prevent more than one bye
    db, cursor = connect()

    cursor.execute(
        "SELECT bye FROM matches WHERE winner=%s;", (pid,))
    pastbye = cursor.fetchone()[0]
    if pastbye == 1:
        return True
    elif pastbye == 0:
        return False
    else:
        print("More than one bye win has been assigned to Player ID: %s in this tournament", (pid,))


def swissPairings(**kwargs):
    """Returns a list of pairs of players for the next round of a match.
  
    The function will check if there is an odd number of players registered in
    the tournament and assign a bye win to one of the players with no bye
    history.

    It will generate a pair list with no player having to rematch with his
    opponent.

    Args:
        tid: the tournament id (Optional). Default as 1.

    Returns:
      A list of tuples, each of which contains (id1, name1, id2, name2)
        id1: the first player's unique id
        name1: the first player's name
        id2: the second player's unique id
        name2: the second player's name
    """
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    scorerank = playerStandings()
    tot_player = countPlayers(tid=tid)
    pair_list = []
    rematchlen = len(scorerank)
    byelen = len(scorerank)

    if tot_player % 2 != 0:
        while byelen > 1:
            i = 0
            while i < byelen - 1:
                if not checkBye(scorerank.pop(i)):
                    bye = scorerank.pop(i)
                    while rematchlen > 1:
                        j = 0
                        while j < rematchlen - 1:
                            pa = scorerank.pop(0)
                            rematchlen = len(scorerank)
                            if not checkRematch(pa[0], scorerank[j][0]):
                                pb = scorerank.pop(j)
                                pair_list.append((pa[0], pa[1], pb[0], pb[1]))
                                j = 0
                                continue
                            else:
                                j += 1
                    pair_list.append((bye[0], bye[1], bye[0], bye[1]))
                else:
                    i += 1
    else:
        while rematchlen > 1:
            j = 0
            while j < rematchlen - 1:
                pa = scorerank.pop(0)
                rematchlen = len(scorerank)
                if not checkRematch(pa[0], scorerank[j][0]):
                    pb = scorerank.pop(j)
                    pair_list.append((pa[0], pa[1], pb[0], pb[1]))
                    j = 0
                    continue
                else:
                    j += 1

    return pair_list
